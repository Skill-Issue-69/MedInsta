# chat_views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.db.models import Prefetch, Q
from django.utils import timezone
import uuid
import logging
import json
from chatbot.models import (
    Symptoms, Messages, Chats,
    Users, Patients, AiDiagnoses,
    Clinicians, QueryCategories
)
from chatbot.final import analyze_medical_text

logger = logging.getLogger(__name__)

VALID_MESSAGE_TYPES = ['text', 'image', 'voice']
VALID_STATUSES = ['open', 'in_review', 'resolved']

def get_system_user():
    user, created = Users.objects.get_or_create(
        email="system@example.com",
        defaults={
            'id': uuid.uuid4(),  # Explicit ID
            'name': 'System AI',
            'role': 'system',
            'password_hash': 'system'
        }
    )
    return user

def format_chat_history(chat_id):
    messages = Messages.objects.filter(chat_id=chat_id).order_by('timestamp')
    return "\n".join([
        f"[{msg.timestamp}] {msg.sender.name} ({msg.message_type}): {msg.message}"
        + (f" [Media: {msg.media_url}]" if msg.media_url else "")
        for msg in messages
    ])

def assign_best_clinician(chat, ai_specialty):
    try:
        clinicians = Clinicians.objects.filter(
            Q(specialization__iexact=ai_specialty) |
            Q(specialization__iexact="General Practice")
        ).distinct().order_by(
            '-rating', 
            'current_chats'
        )

        if not clinicians.exists():
            logger.error("No clinicians available for assignment")
            return None

        best_clinician = clinicians.first()
        best_clinician.current_chats += 1
        best_clinician.save()

        chat.clinician = best_clinician
        chat.status = 'in_review'
        chat.save()
        return best_clinician

    except Exception as e:
        logger.error(f"Clinician assignment error: {str(e)}")
        return None

@api_view(['POST'])
def create_chat(request):
    try:
        system_user = get_system_user()
        data = request.data

        # Validate input
        if not (message_type := data.get('message_type')) or message_type not in VALID_MESSAGE_TYPES:
            return Response({'error': 'Invalid message type'}, status=400)

        if message_type in ['image', 'voice'] and not data.get('media_url'):
            return Response({'error': 'Media URL required'}, status=400)

        try:
            patient = Patients.objects.get(id=uuid.UUID(data['patient_id']))
        except (Patients.DoesNotExist, ValueError):
            return Response({'error': 'Invalid patient ID'}, status=400)

        # Create chat (ID auto-generated by model)
        chat = Chats.objects.create(
            patient=patient,
            status='open'
        )

        # Create symptom with explicit ID
        symptom = Symptoms.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            patient=patient,
            description=data['message'],
            symptom_type=message_type,
            media_url=data.get('media_url')
        )

        # Create initial message with explicit ID
        message = Messages.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            chat=chat,
            sender=patient.id,
            message=data['message'],
            message_type=message_type,
            media_url=data.get('media_url')
        )

        # Process through AI
        chat_history = format_chat_history(chat.id)
        ml_response = analyze_medical_text(chat_history)

        # Store diagnosis with explicit ID
        diagnosis = AiDiagnoses.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            symptom=symptom,
            ai_response=json.dumps(ml_response),
            confidence_score=ml_response.get('confidence', 0.75)
        )

        # Assign clinician
        ai_specialty = ml_response.get('recommended_specialty', 'General Practice')
        assigned_clinician = assign_best_clinician(chat, ai_specialty)

        # Create AI message with explicit ID
        Messages.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            chat=chat,
            sender=system_user,
            message=f"AI Analysis: {ml_response.get('summary', 'Initial assessment')}\n"
                    f"Recommended specialty: {ai_specialty}\n"
                    f"{'Assigned to: Dr. ' + assigned_clinician.id.name + ' (' + assigned_clinician.specialization + ')' if assigned_clinician else 'Awaiting clinician assignment'}",
            message_type='text'
        )

        return Response({
            'chat_id': str(chat.id),
            'symptom_id': str(symptom.id),
            'diagnosis_id': str(diagnosis.id),
            'assigned_clinician': str(assigned_clinician.id.id) if assigned_clinician else None,
            'ai_response': f"AI Analysis: {ml_response.get('summary', 'Initial assessment')}"
        }, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f'Chat creation failed: {str(e)}')
        return Response({'error': 'Chat creation failed'}, status=500)

@api_view(['POST'])
def add_message(request):
    try:
        system_user = get_system_user()
        data = request.data

        # Validate input
        if not (message_type := data.get('message_type')) or message_type not in VALID_MESSAGE_TYPES:
            return Response({'error': 'Invalid message type'}, status=400)

        try:
            chat = Chats.objects.get(id=uuid.UUID(data['chat_id']))
            sender = Users.objects.get(id=uuid.UUID(data['sender_id']))
        except (Chats.DoesNotExist, Users.DoesNotExist, ValueError):
            return Response({'error': 'Invalid chat/sender ID'}, status=400)

        # Create symptom with explicit ID
        symptom = Symptoms.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            patient=chat.patient,
            description=data['message'],
            symptom_type=message_type,
            media_url=data.get('media_url')
        )

        # Create message with explicit ID
        message = Messages.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            chat=chat,
            sender=sender,
            message=data['message'],
            message_type=message_type,
            media_url=data.get('media_url')
        )

        # Process through AI
        chat_history = format_chat_history(chat.id)
        ml_response = analyze_medical_text(chat_history)

        # Update diagnosis with explicit ID
        diagnosis = AiDiagnoses.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            symptom=symptom,
            ai_response=json.dumps(ml_response),
            confidence_score=ml_response.get('confidence', 0.75)
        )

        # Create AI response message with explicit ID
        Messages.objects.create(
            id=uuid.uuid4(),  # Explicit ID
            chat=chat,
            sender=system_user,
            message=f"AI Update: {ml_response.get('summary', 'New analysis')}",
            message_type='text'
        )

        return Response({
            'message_id': str(message.id),
            'diagnosis_id': str(diagnosis.id),
            'ai_response': f"AI Update: {ml_response.get('summary', 'New analysis')}"
        }, status=201)

    except Exception as e:
        logger.error(f'Message error: {str(e)}')
        return Response({'error': 'Message processing failed'}, status=500)

@api_view(['PUT'])
def update_chat(request, chat_id):
    try:
        chat = Chats.objects.get(id=uuid.UUID(chat_id))
    except Chats.DoesNotExist:
        return Response({'error': 'Chat not found'}, status=404)

    data = request.data
    original_status = chat.status
    original_clinician = chat.clinician

    # Status update
    if (new_status := data.get('status')):
        if new_status not in VALID_STATUSES:
            return Response({'error': 'Invalid status'}, status=400)
        
        if new_status == 'resolved' and original_status != 'resolved' and chat.clinician:
            chat.clinician.current_chats = max(0, chat.clinician.current_chats - 1)
            chat.clinician.save()
        
        chat.status = new_status

    # Clinician assignment
    if (clinician_id := data.get('clinician_id')):
        try:
            new_clinician = Clinicians.objects.get(id=uuid.UUID(clinician_id))
            
            if original_clinician:
                original_clinician.current_chats = max(0, original_clinician.current_chats - 1)
                original_clinician.save()
            
            new_clinician.current_chats += 1
            new_clinician.save()
            chat.clinician = new_clinician
            
        except Clinicians.DoesNotExist:
            return Response({'error': 'Clinician not found'}, status=404)

    chat.save()
    return Response({
        'status': chat.status,
        'clinician_id': str(chat.clinician.id.id) if chat.clinician else None,
        'current_chats': chat.clinician.current_chats if chat.clinician else None
    })

@api_view(['GET'])
def get_chats(request, user_id):
    try:
        user = Users.objects.get(id=uuid.UUID(user_id))
    except Users.DoesNotExist:
        return Response({'error': 'User not found'}, status=404)

    chats = Chats.objects.none()

    # Get chats based on user type
    if hasattr(user, 'patients'):
        chats = Chats.objects.filter(patient=user.patients)
    elif hasattr(user, 'clinicians'):
        chats = Chats.objects.filter(clinician=user.clinicians)

    # Prefetch related data
    chats = chats.prefetch_related(
        Prefetch('messages', 
                 queryset=Messages.objects.order_by('-timestamp'), 
                 to_attr='latest_messages')
    ).distinct()

    response_data = []
    for chat in chats:
        latest_message = chat.latest_messages[0] if chat.latest_messages else None
        
        response_data.append({
            'chat_id': str(chat.id),
            'status': chat.status,
            'patient': str(chat.patient.id.id),
            'clinician': str(chat.clinician.id.id) if chat.clinician else None,
            'last_message': {
                'content': latest_message.message if latest_message else None,
                'type': latest_message.message_type if latest_message else None,
                'timestamp': latest_message.timestamp.isoformat() if latest_message else None
            },
            'specialty': chat.clinician.specialization if chat.clinician else None
        })

    # Sort by latest message timestamp
    response_data.sort(
        key=lambda x: x['last_message']['timestamp'] or '1970-01-01T00:00:00Z', 
        reverse=True
    )
    
    return Response(response_data)